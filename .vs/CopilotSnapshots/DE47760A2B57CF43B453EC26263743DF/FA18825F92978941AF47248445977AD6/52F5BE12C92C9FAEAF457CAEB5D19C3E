#define LIGHT_DIRECTIONAL 0
#define LIGHT_POINT 1
#define MAX_LIGHTS 8
#define NUM_CASCADES 4

static const float SHADOW_MAP_SIZE = 2048.0f;

struct Light
{
    int Type;
    float3 Color;

    float3 Direction;
    float Range;

    float3 Position;
    float Intensity;
};

cbuffer CBLight : register(b1)
{
    int LightCount;
    float3 CameraPosition;
    Light Lights[MAX_LIGHTS];
};

cbuffer CBShadow : register(b2)
{
    float4x4 LightViewProj[NUM_CASCADES];
    float4 CascadeSplits; // view-space split depths
};

Texture2D DiffuseTexture : register(t0);
Texture2DArray ShadowMapArray : register(t1);

SamplerState TextureSampler : register(s0);
SamplerComparisonState ShadowSampler : register(s1);

struct PSInput
{
    float4 position : SV_POSITION;
    float3 normalWS : NORMAL;
    float3 posWS : POSITION;
    float2 uv : TEXCOORD0;
    float4 posVS : TEXCOORD1; // view-space position
};

// ----------------------------------------------------
// CASCADE SELECTION
// ----------------------------------------------------
int SelectCascade(float viewDepth)
{
    if (viewDepth < CascadeSplits.x)
        return 0;
    if (viewDepth < CascadeSplits.y)
        return 1;
    if (viewDepth < CascadeSplits.z)
        return 2;
    return 3;
}

// ----------------------------------------------------
// CASCADED SHADOW
// ----------------------------------------------------
float CalculateCascadedShadow(
    float3 posWS,
    float viewDepth,
    float3 normalWS,
    float3 lightDir)
{
    int cascadeIndex = SelectCascade(viewDepth);

    float4 shadowPos = mul(float4(posWS, 1.0f), LightViewProj[cascadeIndex]);
    float3 proj = shadowPos.xyz / shadowPos.w;

    proj.xy = proj.xy * 0.5f + 0.5f;
    proj.y = 1.0f - proj.y;

    if (proj.x < 0 || proj.x > 1 ||
        proj.y < 0 || proj.y > 1 ||
        proj.z < 0 || proj.z > 1)
        return 1.0f;

    float bias = max(0.0005f * (1.0f - dot(normalWS, lightDir)), 0.0001f);

    // Larger PCF kernel for softer shadows
    float shadow = 0.0f;
    float2 texelSize = 1.0f / SHADOW_MAP_SIZE;
    
    // 5x5 PCF kernel with variable weights for smoother falloff
    const int kernelSize = 2; // -2 to +2 = 5x5
    float sampleCount = 0.0f;
    
    [unroll]
    for (int x = -kernelSize; x <= kernelSize; ++x)
    {
        [unroll]
        for (int y = -kernelSize; y <= kernelSize; ++y)
        {
            float2 offset = float2(x, y) * texelSize * 1.5f;
            
            shadow += ShadowMapArray.SampleCmpLevelZero(
                ShadowSampler,
                float3(proj.xy + offset, cascadeIndex),
                proj.z - bias
            );
            sampleCount += 1.0f;
        }
    }

    return shadow / sampleCount;
}

// ----------------------------------------------------
// PIXEL ENTRY POINT
// ----------------------------------------------------
float4 main(PSInput input) : SV_TARGET
{
    float3 N = normalize(input.normalWS);
    float3 V = normalize(CameraPosition - input.posWS);

    float3 albedo = DiffuseTexture.Sample(TextureSampler, input.uv).rgb;

    float viewDepth = abs(input.posVS.z);

    // Ambient light so shadows aren't pitch black
    float3 ambient = albedo * 0.15f;
    float3 color = ambient;

    for (int i = 0; i < LightCount; ++i)
    {
        Light light = Lights[i];

        float3 L;
        float attenuation = 1.0f;
        float shadow = 1.0f;

        if (light.Type == LIGHT_DIRECTIONAL)
        {
            L = normalize(-light.Direction);
            shadow = CalculateCascadedShadow(
                input.posWS,
                viewDepth,
                N,
                L
            );
        }
        else
        {
            float3 toLight = light.Position - input.posWS;
            float dist = length(toLight);
            L = toLight / dist;

            attenuation = saturate(1.0f - dist / light.Range);
            attenuation *= attenuation;
        }

        float diff = max(dot(N, L), 0.0f);
        float3 H = normalize(L + V);
        float spec = pow(max(dot(N, H), 0.0f), 16.0f);

        color +=
            albedo *
            (diff + spec * 0.25f) *
            light.Color *
            light.Intensity *
            attenuation *
            shadow;
    }

    return float4(color, 1.0f);
}
